/**
 * @fileoverview Core API for methods
 * @author Dominik Ferber
 * @copyright 2015 Dominik Ferber. All rights reserved.
 * See LICENSE file in root directory for full license.
 */

'use strict';

var _utilEnvironment = require('../util/environment');

var _util = require('../util');

var _utilAst = require('../util/ast');

// -----------------------------------------------------------------------------
// Rule Definition
// -----------------------------------------------------------------------------

var methodProps = ['userId', 'setUserId', 'isSimulation', 'unblock', 'connection'];

module.exports = function (getMeta) {
  return function (context) {
    var _getMeta = getMeta(context);

    var env = _getMeta.env;

    // ---------------------------------------------------------------------------
    // Helpers
    // ---------------------------------------------------------------------------

    function expectAtLeastOneArgument(node) {
      if (node.arguments.length === 0) {
        context.report(node, 'At least one argument expected');
      }
    }

    function expectAtLeastTwoArguments(node) {
      if (node.arguments.length < 2) {
        context.report(node, 'At least two arguments expected');
      }
    }

    function isMethodProp(property) {
      return methodProps.indexOf((0, _utilAst.getPropertyName)(property)) !== -1;
    }

    function verifyNoCall( /* MemberExpression */node) {
      if (node.parent.type === 'CallExpression' && node.parent.callee === node) {
        context.report(node.parent, 'Not a function');
      }
    }

    function verifyNoReassignment( /* MemberExpression */node) {
      if (node.parent.type === 'AssignmentExpression' && node.parent.left === node) {
        context.report(node.parent, 'Assignment not allowed');
      } else if (node.parent.type === 'UpdateExpression') {
        context.report(node.parent, 'Update not allowed');
      }
    }

    function isInCallingPosition( /* MemberExpression */node) {
      return node.parent.type === 'CallExpression' && node.parent.callee === node;
    }

    function verifyContextApi(node, executors) {
      var propName = (0, _utilAst.getPropertyName)(node.property);
      switch (propName) {
        case 'userId':
          verifyNoCall(node);
          verifyNoReassignment(node);
          break;
        case 'setUserId':
          if (executors.has('browser') || executors.has('cordova')) {
            return context.report(node.parent, 'Allowed on server only');
          }

          if (isInCallingPosition(node) && node.parent.arguments.length !== 1) {
            return context.report(node.parent, 'Expected one argument');
          }
          verifyNoReassignment(node);
          break;
        case 'isSimulation':
          break;
        case 'unblock':
          break;
        case 'connection':
          break;
      }
    }

    function isMethodContext(scope) {
      return scope.type === 'function' && scope.block.type === 'FunctionExpression' && !!scope.block.parent && scope.block.parent.type === 'Property' && scope.block.parent.value === scope.block && scope.block.parent.parent.type === 'ObjectExpression' && scope.block.parent.parent.parent.type === 'CallExpression' && (0, _utilAst.isMeteorCall)(scope.block.parent.parent.parent, 'methods');
    }

    // ---------------------------------------------------------------------------
    // Public
    // ---------------------------------------------------------------------------

    if (env === _utilEnvironment.NON_METEOR) {
      return {};
    }

    return {

      NewExpression: function NewExpression(node) {

        if (!(0, _utilAst.isMeteorProp)(node.callee, 'Error')) {
          return;
        }

        var executors = (0, _util.getExecutors)(env, context.getAncestors());
        if (executors.size === 0) {
          return;
        }

        if (node.arguments.length === 0) {
          expectAtLeastOneArgument(node);
        } else if (node.arguments[0].type === 'Literal' && typeof node.arguments[0].value !== 'string') {
          context.report(node.arguments[0], 'Expected a string');
        }
      },

      CallExpression: function CallExpression(node) {

        var executors = (0, _util.getExecutors)(env, context.getAncestors());
        if (executors.size === 0) {
          return;
        }

        if ((0, _utilAst.isMeteorCall)(node, 'apply')) {
          expectAtLeastTwoArguments(node);
        } else if ((0, _utilAst.isMeteorCall)(node, 'call')) {
          expectAtLeastOneArgument(node);
        } else if ((0, _utilAst.isMeteorCall)(node, 'Error')) {
          context.report(node, 'Missing "new" keyword');
        } else if ((0, _utilAst.isMeteorCall)(node, 'methods')) {
          if (node.arguments.length !== 1) {
            context.report(node, 'Expected one argument');
          }
        }
      },

      MemberExpression: function MemberExpression(node) {

        // not accesing one of the publish API props
        if (!isMethodProp(node.property)) {
          return;
        }

        var executors = (0, _util.getExecutors)(env, context.getAncestors());
        if (executors.size === 0) {
          return;
        }

        var scope = context.getScope();
        switch (node.object.type) {
          case 'ThisExpression':
            {
              if ((0, _utilAst.hasContext)(scope, isMethodContext)) {
                verifyContextApi(node, executors);
              }
              break;
            }
          case 'Identifier':
            {
              var resolvedVar = scope.resolve(node.object);
              if (resolvedVar && (0, _utilAst.refersTo)(resolvedVar.resolved, isMethodContext)) {
                verifyContextApi(node, executors);
              }
              break;
            }
        }
      }
    };
  };
};

module.exports.schema = [];